.\" Copyright (C) 2024-2025 SUSE LLC <petr.pavlu@suse.com>
.\" SPDX-License-Identifier: GPL-2.0-or-later
.TH SUSE-KABI-TOOLS 5
.SH NAME
suse-kabi-tools \- Linux-kernel Application Binary Interface (ABI) definition files
.SH DESCRIPTION
suse-kabi-tools operate on several data formats: symbol types (symtypes), symbol versions (symvers),
consolidated symtypes, and kABI severity rules.
.PP
The symtypes and symvers data files are generated by the Linux kernel build, and their format is
effectively defined by the Linux project. The consolidated symtypes and kABI severity rules are
custom formats defined specifically by suse-kabi-tools.
.PP
This document describes these formats.
.SH SYMBOL TYPES
.SS DESCRIPTION
Symtypes files provide detailed information about the ABI in the Linux kernel. The format describes
exported functions, variables and their dependent types as known in a single object file. The data
is generated by the \fBgenksyms\fR utility from the kernel tree. It records the type information
that was used by the tool to calculate a signature (CRC) of each symbol.
.SS FORMAT
A symtypes file consists of type records, one per line. Each record is comprised of a type
identifier and an associated type description, separated by whitespace.
.PP
A type identifier can be one of the following:
.RS
.IP \[bu] 2
<exported-name> \(en an exported function or variable definition (no prefix),
.IP \[bu] 2
t#<typedef-name> \(en a typedef definition,
.IP \[bu] 2
e#<enum-name> \(en an enumeration definition,
.IP \[bu] 2
s#<struct-name> \(en a structure definition,
.IP \[bu] 2
u#<union-name> \(en a union definition,
.IP \[bu] 2
E#<enum-constant-name> \(en an enumerator definition.
.RE
.PP
A type description consists of a list of tokens, separated by whitespace. A single token can be a
literal value directly contributing to the type definition or a type reference. References are in
the form "<x>#<type-name>" and point to another type defined in the file.
.PP
A type name can be optionally enclosed in single quotes, both when when defining the type and when
referencing it. This allows the type name to contain spaces.
.SS EXAMPLES
The following example shows the file \fIa.symtypes\fR. The data records the exported function "baz",
which takes as its parameters the structure "foo" and a pointer to the union "bar". The structure
"foo" has a complete definition in the file, while the union "bar" is an opaque declaration.
.IP
.EX
$ cat a.symtypes
s#foo struct foo { int m ; }
u#bar union bar { UNKNOWN }
baz void baz ( s#foo a1 , u#bar * a2 )
.EE
.SH SYMBOL VERSIONS
.SS DESCRIPTION
A symvers file provides final information about the ABI in the Linux kernel. The file summarizes
data that was embedded during the Linux kernel build into the main kernel binary and loadable
modules to detect compatibility between symbol references and associated definitions. The data is
generated by the \fBmodpost\fR utility from the kernel tree.
.SS FORMAT
A symvers file consists of symbol records, one per line. Each record is comprised of a 32-bit symbol
CRC, a symbol name, a module name, an export type and optionally a namespace identifier, all
separated by whitespace.
.SS EXAMPLES
The following example shows the file \fIModule.symvers\fR. The data records two exported functions
"baz" and "qux". The symbol "baz" has a CRC of 0x12345678, originates from the main kernel binary
and is a regular export. The symbol "qux" has a CRC of 0x90abcdef, originates from the lib/test
module, is a GPL-only export and is defined in the BAR_NS namespace.
.IP
.EX
$ cat Module.symvers
0x12345678 baz vmlinux  EXPORT_SYMBOL
0x90abcdef qux lib/test EXPORT_SYMBOL_GPL BAR_NS
.EE
.SH CONSOLIDATED SYMBOL TYPES
.SS DESCRIPTION
The consolidated symtypes format extends the base symtypes format to efficiently describe types
across multiple object files. This allows to have one file for the entire kernel ABI. The format is
generated by the \fBksymtypes\fR \fBconsolidate\fR command.
.SS FORMAT
The format introduces the concept of file sections, with each section starting with a special record
in the form "/* <file-name> */". The content of each section can be trivially same as in the case of
the base symtypes format. However, two extensions are present to save storage space.
.PP
A file section can omit a type definition if it is the same as its last definition previously
encountered in the consolidated file. A reader can implicitly determine its presence be by
recursively walking all exports in the specific file.
.PP
A file section can transform opaque declarations in the form "<short-type>#<name> <type> <name> {
UNKNOWN }" to "<short-type>##<name>". For instance, "s#task_struct struct task_struct { UNKNOWN }"
becomes "s##task_struct". Such definitions apply only to the current file section and do not
override the last definition of the symbol.
.SS EXAMPLES
The following example shows two files \fIa.symtypes\fR and \fI.b.symtypes\fR using the base format.
The first file \fIa.symtypes\fR records the exported function "baz", which takes as its parameters
the structure "foo" and a pointer to the union "bar", with the former having a complete definition
and the latter being an opaque declaration. The second file \fIb.symtypes\fR records the exported
function "qux", which takes as its parameters the structure "foo" and a pointer to the union "bar",
with both types having a complete definition.
.IP
.EX
$ cat example/a.symtypes
s#foo struct foo { int m ; }
u#bar union bar { UNKNOWN }
baz void baz ( s#foo a1 , u#bar * a2 )
.EE
.IP
.EX
$ cat example/b.symtypes
s#foo struct foo { int m ; }
u#bar union bar { int i; float f; }
qux void qux ( s#foo a1 , u#bar * a2 )
.EE
.PP
The following example shows the file \fIc.symtypes\fR, which is produced by consolidating the
previous two files \fIa.symtypes\fR and \fIb.symtypes\fR. The structure type "foo", which was the
same in both files, is merged; the union type "bar" appears in two different variants.
.IP
.EX
$ ksymtypes consolidate --output=example/c.kabi example/
$ cat example/c.kabi
/* a.symtypes */
s#foo struct foo { int m ; }
u##bar
baz void baz ( s#foo a1 , u#bar * a2 )

/* b.symtypes */
u#bar union bar { int i; float f; }
qux void qux ( s#foo a1 , u#bar * a2 )
.EE
.SH KABI SEVERITY RULES
.SS DESCRIPTION
A kABI severity file provides rules to be used in the comparison of symvers data.
.SS FORMAT
A kABI severity file consists of rules, one per line. Each rule is comprised of a pattern
and an associated verdict, separated by whitespace.
.PP
A pattern can be one of the following:
.RS
.IP \[bu] 2
<module-name> \(en a module name, indicated by the presence of the character "/" in the name, or by
the name being literally "vmlinux",
.IP \[bu] 2
<namespace-identifier> \(en a namespace identifier, indicated by all letters being capital,
.IP \[bu] 2
<symbol-name> \(en a symbol name, the default case.
.RE
.PP
A pattern can contain the shell wildcards "*" and "?", with their usual meaning.
.PP
A verdict can be either "PASS" or "FAIL".
.PP
The file can contain comments beginning with "#", which extend to the end of the line. Rules are
ordered, and the first match takes effect.
.SS EXAMPLES
The following example shows the file \fIseverity.rules\fR, which defines three rules. The first rule
is a module rule that indicates all changes in modules matching "lib/important*" should result in a
failure. The second rule is a namespace rule that indicates all changes in the namespace
"TEST_IMPORTANT" should result in a failure. The last rule is a symbol rule that indicates all
changes to symbols matching "*not_stable*" can be ignored.
.IP
.EX
$ cat severity.rules
lib/important* FAIL
TEST_IMPORTANT FAIL
*not_stable*   PASS
.EE
.SH SEE ALSO
\fBksymtypes\fR(1), \fBksymvers\fR(1)
